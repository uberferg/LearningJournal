<!doctype html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <title>Learning Modern Web Graphics</title>

  <link href='../css/bootstrap.min.css' rel='stylesheet'>
</head>

<body>
<div class='container'>
  <h1>
    <a href='index.html'>Learning Web Graphics with Canvas and WebGL</a>
  </h1>
  <div class='col-md-8'>

  <p>
  This is a site to keep track of things as I try to teach
  myself WebGL.
  </p>

  <h2>
    <a href='lesson01_helloCanvas.html'>First steps with the canvas API</a>
  </h2>
  <p>
  This lesson introduces the canvas element, its coordinate
  system, and some of its 2-dimensional drawing methods.
  </p>

  <h2>Making an analog clock with canvas</h2>
  <p>
  This lesson provides a more in-depth look at the 2-dimensional
  canvas methods, including gradients and textures, by creating
  a 'wooden' analog clock.
  </p>
  <a href='canvasClock.html'>canvasClock</a>

  <h2>Introducing WebGL</h2>
  <p>
  If you look ahead at the source code for this section, you'll
  notice that it takes quite a formidable number of lines to
  create a simple triangle. One of the primary reasons for this
  is that WebGL is entirely shader based. This means that every
  WebGL application, no matter how simple, requires both a vertex
  shader and a fragment shader to draw even basic shapes.
  </p>
  <p>
  These shaders run directly on the GPU, unlike other JavaScript 
  which is handled by the browser, and therefore have to be
  written in the GL Shading Language (GLSL). This
  source code then needs to be compiled and linked at run time before
  it can be used as a shader program by the GPU. Setting up
  this process happens :
  <ol>
    <li>
  </ol>
  <a href='helloGL.html'>helloGL</a>

  </div>
</div>

<script src='../js.bootstrap.min.js'></script>  
</body>
</html>
